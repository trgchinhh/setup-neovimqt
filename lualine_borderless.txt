lua << EOF
-- màu custom cho cảnh báo và lỗi
local diag_colors = {
  warning_bg = '#D7BA7D', -- vàng giống VSCode warning
  error_bg   = '#F44747', -- đỏ giống VSCode error
  fg         = '#ffffff',
}

-- nhớ file cuối cùng khi chuyển terminal
local last_file = ''

-- lấy theme onedark
local theme = require("lualine.themes.onedark")

-- lấy màu nền thật sự của editor (Normal bg)
local normal_bg = vim.api.nvim_get_hl(0, { name = "Normal" }).bg
if normal_bg then
  normal_bg = string.format("#%06x", normal_bg)
else
  normal_bg = "#1e222a" -- fallback nếu không có
end

-- ép phần dư (c section) có cùng màu với background editor
for _, mode in pairs({ "normal", "insert", "visual", "replace", "command", "inactive" }) do
  theme[mode].c = { fg = "#abb2bf", bg = normal_bg }
end

require("lualine").setup {
  options = {
    theme = theme,
    section_separators = { left = '', right = '' },
    component_separators = { left = '', right = '' },
    icons_enabled = true,
    always_divide_middle = false,
    globalstatus = true,
  },

  sections = {
    lualine_a = { 'mode' },

    lualine_b = {
      {
        'branch',
        color = { fg = "#FFFFFF", bg = nil }, -- chữ trắng
        separator = '' -- bỏ separator mặc định
      },
      {
        function() return '' end, -- dấu ngăn
        color = { fg = "#FFFFFF", bg = nil }, -- màu trắng
        padding = { left = 0, right = 0 },
      },
      {
        'diff',
        color = { fg = nil, bg = nil },
        separator = ''
      },
      -- 
      {
        function() return '' end,
        color = { fg = "#FFFFFF", bg = nil },
        padding = { left = 0, right = 0 },
      },
    },

    lualine_c = {
      {
        function()
          local buftype = vim.bo.buftype
          local fname = vim.api.nvim_buf_get_name(0)

          if buftype == 'terminal' then
            if last_file ~= '' then
              return vim.fn.fnamemodify(last_file, ':p')
            else
              return '[Terminal]'
            end
          end

          if fname ~= '' then
            last_file = fname
            return vim.fn.fnamemodify(fname, ':p')
          else
            return '[No Name]'
          end
        end,
        color = { fg = '#ffffff', bg = normal_bg },
      }
    },

    lualine_x = {
      {
        'filetype',
        icons_enabled = false,
        color = { fg = "#ffffff", bg = normal_bg },
      },
    },

    lualine_y = {
      { function() return '' end, color = { fg = "#FFFFFF", bg = normal_bg }, padding = { left = 0, right = 0 } },
      {
        function()
          local enc = vim.bo.fenc ~= '' and vim.bo.fenc or vim.o.enc
          local ff = vim.bo.ff
          local ff_icon = (ff == 'unix' and '') or (ff == 'dos' and '') or (ff == 'mac' and '') or ''
          return string.format('%s[%s %s]', enc, ff, ff_icon)
        end,
        color = { fg = "#FFFFFF", bg = nil },
        separator = '',
      },
    },

    lualine_z = {
      'progress',

      -- vị trí dòng/cột
      function()
        local current = vim.fn.line('.')
        local total = vim.fn.line('$')
        local col = vim.fn.col('.')
        return string.format('\u{E0A1}: %d/%d \u{E0B3} @ %d', current, total, col)
      end,

      -- warning count
      {
        function()
          local ok, result = pcall(vim.fn['CocAction'], 'diagnosticList')
          if not (ok and result and #result > 0) then return '' end
          local warning_count, first_warning_line = 0, nil
          for _, item in ipairs(result) do
            if item.severity == 'Warning' then
              warning_count = warning_count + 1
              if not first_warning_line or item.lnum < first_warning_line then
                first_warning_line = item.lnum
              end
            end
          end
          if warning_count > 0 then
            return string.format('W:%d (L%d)', warning_count, first_warning_line)
          end
          return ''
        end,
        color = { fg = diag_colors.fg, bg = diag_colors.warning_bg },
        separator = { left = '' }
      },

      -- error count
      {
        function()
          local ok, result = pcall(vim.fn['CocAction'], 'diagnosticList')
          if not (ok and result and #result > 0) then return '' end
          local error_count, first_error_line = 0, nil
          for _, item in ipairs(result) do
            if item.severity == 'Error' then
              error_count = error_count + 1
              if not first_error_line or item.lnum < first_error_line then
                first_error_line = item.lnum
              end
            end
          end
          if error_count > 0 then
            return string.format('E:%d (L%d)', error_count, first_error_line)
          end
          return ''
        end,
        color = { fg = diag_colors.fg, bg = diag_colors.error_bg },
        separator = { left = '' }
      },
    },
  },

  tabline = {
    lualine_a = {
      {
        'buffers',
        mode = 2,
        symbols = {
          modified = ' ●',
          alternate_file = '',
          directory = '',
        },
      },
    },
    lualine_z = {
      function() return "buffers" end,
    },
  },

  extensions = { 'nvim-tree', 'quickfix', 'fugitive' },
}
EOF
